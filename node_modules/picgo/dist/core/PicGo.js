"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const events_1 = require("events");
const os_1 = require("os");
const Commander_1 = __importDefault(require("../lib/Commander"));
const Logger_1 = __importDefault(require("../lib/Logger"));
const Lifecycle_1 = __importDefault(require("./Lifecycle"));
const LifecyclePlugins_1 = __importDefault(require("../lib/LifecyclePlugins"));
const uploader_1 = __importDefault(require("../plugins/uploader"));
const transformer_1 = __importDefault(require("../plugins/transformer"));
const config_1 = require("../utils/config");
const PluginLoader_1 = __importDefault(require("../lib/PluginLoader"));
const lodash_1 = require("lodash");
const getClipboardImage_1 = __importDefault(require("../utils/getClipboardImage"));
const Request_1 = __importDefault(require("../lib/Request"));
class PicGo extends events_1.EventEmitter {
    constructor(configPath = '') {
        super();
        this.configPath = configPath;
        this.output = [];
        this.input = [];
        this.helper = {
            transformer: new LifecyclePlugins_1.default('transformer'),
            uploader: new LifecyclePlugins_1.default('uploader'),
            beforeTransformPlugins: new LifecyclePlugins_1.default('beforeTransformPlugins'),
            beforeUploadPlugins: new LifecyclePlugins_1.default('beforeUploadPlugins'),
            afterUploadPlugins: new LifecyclePlugins_1.default('afterUploadPlugins')
        };
        this.log = new Logger_1.default(this);
        this.cmd = new Commander_1.default(this);
        this.init();
    }
    init() {
        if (this.configPath === '') {
            this.configPath = os_1.homedir() + '/.picgo/config.json';
        }
        this.baseDir = path_1.default.dirname(this.configPath);
        const exist = fs_extra_1.default.pathExistsSync(this.configPath);
        if (!exist) {
            fs_extra_1.default.ensureFileSync(`${this.configPath}`);
        }
        try {
            // init config
            const config = config_1.getConfig(this.configPath).read().value();
            this.config = config;
            // load self plugins
            this.Request = new Request_1.default(this);
            this.pluginLoader = new PluginLoader_1.default(this);
            uploader_1.default(this);
            transformer_1.default(this);
            // load third-party plugins
            this.pluginLoader.load();
            this.lifecycle = new Lifecycle_1.default(this);
        }
        catch (e) {
            this.emit('uploadProgress', -1);
            this.log.error(e);
            Promise.reject(e);
        }
    }
    // register commandline commands
    // please mannually remove listeners for avoiding listeners memory leak
    registerCommands() {
        this.cmd.init();
        this.cmd.loadCommands();
    }
    // get config
    getConfig(name = '') {
        if (name) {
            return lodash_1.get(this.config, name);
        }
        else {
            return this.config;
        }
    }
    // save to db
    saveConfig(config) {
        config_1.saveConfig(this.configPath, config);
        this.setConfig(config);
    }
    // set config for ctx but will not be saved to db
    // it's more lightweight
    setConfig(config) {
        Object.keys(config).forEach((name) => {
            lodash_1.set(this.config, name, config[name]);
        });
    }
    async upload(input) {
        // upload from clipboard
        if (input === undefined || input.length === 0) {
            try {
                const imgPath = await getClipboardImage_1.default(this);
                if (imgPath === 'no image') {
                    this.emit('notification', {
                        title: 'image not found in clipboard',
                        body: 'copy image first'
                    });
                    this.log.warn('no image to upload');
                }
                else {
                    this.once('failed', async () => {
                        await fs_extra_1.default.remove(imgPath);
                    });
                    this.once('finished', async () => {
                        await fs_extra_1.default.remove(imgPath);
                    });
                    await this.lifecycle.start([imgPath]);
                }
            }
            catch (e) {
                this.log.error(e);
                throw e;
            }
        }
        else {
            // upload from path
            await this.lifecycle.start(input);
        }
    }
}
exports.default = PicGo;
